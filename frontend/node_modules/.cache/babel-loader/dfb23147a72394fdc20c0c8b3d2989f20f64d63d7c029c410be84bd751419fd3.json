{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { useTheme } from '@mui/material/styles';\nimport ChartsContinuousGradient from '../internals/components/ChartsAxesGradients/ChartsContinuousGradient';\nimport { useChartId, useDrawingArea } from '../hooks';\nimport { getScale } from '../internals/getScale';\nimport { getPercentageValue } from '../internals/getPercentageValue';\nimport { ChartsText } from '../ChartsText';\nimport { getStringSize } from '../internals/domUtils';\nimport { useAxis } from './useAxis';\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nfunction getPositionOffset(position, legendBox, svgBox) {\n  let offsetX = 0;\n  let offsetY = 0;\n  switch (position.horizontal) {\n    case 'left':\n      offsetX = 0;\n      break;\n    case 'middle':\n      offsetX = (svgBox.width - legendBox.width) / 2;\n      break;\n    case 'right':\n    default:\n      offsetX = svgBox.width - legendBox.width;\n      break;\n  }\n  switch (position.vertical) {\n    case 'top':\n      offsetY = 0;\n      break;\n    case 'middle':\n      offsetY = (svgBox.height - legendBox.height) / 2;\n      break;\n    case 'bottom':\n    default:\n      offsetY = svgBox.height - legendBox.height;\n      break;\n  }\n  return {\n    offsetX,\n    offsetY\n  };\n}\n\n/**\n * Takes placement parameters and element bounding boxes.\n * Returns the x, y coordinates of the elements. And the textAnchor, dominantBaseline for texts.\n */\nfunction getElementPositions(text1Box, barBox, text2Box, params) {\n  if (params.direction === 'column') {\n    const text1 = {\n      y: text1Box.height,\n      dominantBaseline: 'auto'\n    };\n    const text2 = {\n      y: text1Box.height + 2 * params.spacing + barBox.height,\n      dominantBaseline: 'hanging'\n    };\n    const bar = {\n      y: text1Box.height + params.spacing\n    };\n    const totalWidth = Math.max(text1Box.width, barBox.width, text2Box.width);\n    const totalHeight = text1Box.height + barBox.height + text2Box.height + 2 * params.spacing;\n    const boundingBox = {\n      width: totalWidth,\n      height: totalHeight\n    };\n    switch (params.align) {\n      case 'start':\n        return {\n          text1: _extends({}, text1, {\n            textAnchor: 'start',\n            x: 0\n          }),\n          text2: _extends({}, text2, {\n            textAnchor: 'start',\n            x: 0\n          }),\n          bar: _extends({}, bar, {\n            x: 0\n          }),\n          boundingBox\n        };\n      case 'end':\n        return {\n          text1: _extends({}, text1, {\n            textAnchor: 'end',\n            x: totalWidth\n          }),\n          text2: _extends({}, text2, {\n            textAnchor: 'end',\n            x: totalWidth\n          }),\n          bar: _extends({}, bar, {\n            x: totalWidth - barBox.width\n          }),\n          boundingBox\n        };\n      case 'middle':\n      default:\n        return {\n          text1: _extends({}, text1, {\n            textAnchor: 'middle',\n            x: totalWidth / 2\n          }),\n          text2: _extends({}, text2, {\n            textAnchor: 'middle',\n            x: totalWidth / 2\n          }),\n          bar: _extends({}, bar, {\n            x: totalWidth / 2 - barBox.width / 2\n          }),\n          boundingBox\n        };\n    }\n  } else {\n    const text1 = {\n      x: text1Box.width,\n      textAnchor: 'end'\n    };\n    const text2 = {\n      x: text1Box.width + 2 * params.spacing + barBox.width,\n      textAnchor: 'start'\n    };\n    const bar = {\n      x: text1Box.width + params.spacing\n    };\n    const totalHeight = Math.max(text1Box.height, barBox.height, text2Box.height);\n    const totalWidth = text1Box.width + barBox.width + text2Box.width + 2 * params.spacing;\n    const boundingBox = {\n      width: totalWidth,\n      height: totalHeight\n    };\n    switch (params.align) {\n      case 'start':\n        return {\n          text1: _extends({}, text1, {\n            dominantBaseline: 'hanging',\n            y: 0\n          }),\n          text2: _extends({}, text2, {\n            dominantBaseline: 'hanging',\n            y: 0\n          }),\n          bar: _extends({}, bar, {\n            y: 0\n          }),\n          boundingBox\n        };\n      case 'end':\n        return {\n          text1: _extends({}, text1, {\n            dominantBaseline: 'auto',\n            y: totalHeight\n          }),\n          text2: _extends({}, text2, {\n            dominantBaseline: 'auto',\n            y: totalHeight\n          }),\n          bar: _extends({}, bar, {\n            y: totalHeight - barBox.height\n          }),\n          boundingBox\n        };\n      case 'middle':\n      default:\n        return {\n          text1: _extends({}, text1, {\n            dominantBaseline: 'central',\n            y: totalHeight / 2\n          }),\n          text2: _extends({}, text2, {\n            dominantBaseline: 'central',\n            y: totalHeight / 2\n          }),\n          bar: _extends({}, bar, {\n            y: totalHeight / 2 - barBox.height / 2\n          }),\n          boundingBox\n        };\n    }\n  }\n}\nconst defaultLabelFormatter = _ref => {\n  let {\n    formattedValue\n  } = _ref;\n  return formattedValue;\n};\nfunction ContinuousColorLegend(props) {\n  var _colorMap$min, _colorMap$max, _axisItem$valueFormat, _axisItem$valueFormat2, _axisItem$valueFormat3, _axisItem$valueFormat4;\n  const theme = useTheme();\n  const {\n    id: idProp,\n    minLabel = defaultLabelFormatter,\n    maxLabel = defaultLabelFormatter,\n    scaleType = 'linear',\n    direction,\n    length = '50%',\n    thickness = 5,\n    spacing = 4,\n    align = 'middle',\n    labelStyle = theme.typography.subtitle1,\n    position,\n    axisDirection,\n    axisId\n  } = props;\n  const chartId = useChartId();\n  const id = idProp !== null && idProp !== void 0 ? idProp : \"gradient-legend-\".concat(chartId);\n  const isRTL = theme.direction === 'rtl';\n  const axisItem = useAxis({\n    axisDirection,\n    axisId\n  });\n  const {\n    width,\n    height,\n    left,\n    right,\n    top,\n    bottom\n  } = useDrawingArea();\n  const refLength = direction === 'column' ? height + top + bottom : width + left + right;\n  const size = getPercentageValue(length, refLength);\n  const isReversed = direction === 'column';\n  const colorMap = axisItem === null || axisItem === void 0 ? void 0 : axisItem.colorMap;\n  if (!colorMap || !colorMap.type || colorMap.type !== 'continuous') {\n    return null;\n  }\n\n  // Define the coordinate to color mapping\n\n  const colorScale = axisItem.colorScale;\n  const minValue = (_colorMap$min = colorMap.min) !== null && _colorMap$min !== void 0 ? _colorMap$min : 0;\n  const maxValue = (_colorMap$max = colorMap.max) !== null && _colorMap$max !== void 0 ? _colorMap$max : 100;\n  const scale = getScale(scaleType, [minValue, maxValue], isReversed ? [size, 0] : [0, size]);\n\n  // Get texts to display\n\n  const formattedMin = (_axisItem$valueFormat = (_axisItem$valueFormat2 = axisItem.valueFormatter) === null || _axisItem$valueFormat2 === void 0 ? void 0 : _axisItem$valueFormat2.call(axisItem, minValue, {\n    location: 'legend'\n  })) !== null && _axisItem$valueFormat !== void 0 ? _axisItem$valueFormat : minValue.toLocaleString();\n  const formattedMax = (_axisItem$valueFormat3 = (_axisItem$valueFormat4 = axisItem.valueFormatter) === null || _axisItem$valueFormat4 === void 0 ? void 0 : _axisItem$valueFormat4.call(axisItem, maxValue, {\n    location: 'legend'\n  })) !== null && _axisItem$valueFormat3 !== void 0 ? _axisItem$valueFormat3 : maxValue.toLocaleString();\n  const minText = typeof minLabel === 'string' ? minLabel : minLabel({\n    value: minValue !== null && minValue !== void 0 ? minValue : 0,\n    formattedValue: formattedMin\n  });\n  const maxText = typeof maxLabel === 'string' ? maxLabel : maxLabel({\n    value: maxValue !== null && maxValue !== void 0 ? maxValue : 0,\n    formattedValue: formattedMax\n  });\n  const text1 = isReversed ? maxText : minText;\n  const text2 = isReversed ? minText : maxText;\n  const text1Box = getStringSize(text1, _extends({}, labelStyle));\n  const text2Box = getStringSize(text2, _extends({}, labelStyle));\n\n  // Place bar and texts\n\n  const barBox = direction === 'column' || isRTL && direction === 'row' ? {\n    width: thickness,\n    height: size\n  } : {\n    width: size,\n    height: thickness\n  };\n  const legendPositions = getElementPositions(text1Box, barBox, text2Box, {\n    spacing,\n    align,\n    direction\n  });\n  const svgBoundingBox = {\n    width: width + left + right,\n    height: height + top + bottom\n  };\n  const positionOffset = getPositionOffset(_extends({\n    horizontal: 'middle',\n    vertical: 'top'\n  }, position), legendPositions.boundingBox, svgBoundingBox);\n  return /*#__PURE__*/_jsxs(React.Fragment, {\n    children: [/*#__PURE__*/_jsx(ChartsContinuousGradient, {\n      isReversed: isReversed,\n      gradientId: id,\n      size: size,\n      direction: direction === 'row' ? 'x' : 'y',\n      scale: scale,\n      colorScale: colorScale,\n      colorMap: colorMap,\n      gradientUnits: \"objectBoundingBox\"\n    }), /*#__PURE__*/_jsx(ChartsText, {\n      text: text1,\n      x: positionOffset.offsetX + legendPositions.text1.x,\n      y: positionOffset.offsetY + legendPositions.text1.y,\n      style: _extends({\n        dominantBaseline: legendPositions.text1.dominantBaseline,\n        textAnchor: legendPositions.text1.textAnchor\n      }, labelStyle)\n    }), /*#__PURE__*/_jsx(\"rect\", _extends({\n      x: positionOffset.offsetX + legendPositions.bar.x,\n      y: positionOffset.offsetY + legendPositions.bar.y\n    }, barBox, {\n      fill: \"url(#\".concat(id, \")\")\n    })), /*#__PURE__*/_jsx(ChartsText, {\n      text: text2,\n      x: positionOffset.offsetX + legendPositions.text2.x,\n      y: positionOffset.offsetY + legendPositions.text2.y,\n      style: _extends({\n        dominantBaseline: legendPositions.text2.dominantBaseline,\n        textAnchor: legendPositions.text2.textAnchor\n      }, labelStyle)\n    })]\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? ContinuousColorLegend.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * The alignment of the texts with the gradient bar.\n   * @default 'middle'\n   */\n  align: PropTypes.oneOf(['end', 'middle', 'start']),\n  /**\n   * The axis direction containing the color configuration to represent.\n   * @default 'z'\n   */\n  axisDirection: PropTypes.oneOf(['x', 'y', 'z']),\n  /**\n   * The id of the axis item with the color configuration to represent.\n   * @default The first axis item.\n   */\n  axisId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  /**\n   * The direction of the legend layout.\n   * The default depends on the chart.\n   */\n  direction: PropTypes.oneOf(['column', 'row']),\n  /**\n   * A unique identifier for the gradient.\n   * @default auto-generated id\n   */\n  id: PropTypes.string,\n  /**\n   * The style applied to labels.\n   * @default theme.typography.subtitle1\n   */\n  labelStyle: PropTypes.object,\n  /**\n   * The length of the gradient bar.\n   * Can be a number (in px) or a string with a percentage such as '50%'.\n   * The '100%' is the length of the svg.\n   * @default '50%'\n   */\n  length: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  /**\n   * The label to display at the maximum side of the gradient.\n   * Can either be a string, or a function.\n   * If not defined, the formatted maximal value is display.\n   * @default ({ formattedValue }) => formattedValue\n   */\n  maxLabel: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  /**\n   * The label to display at the minimum side of the gradient.\n   * Can either be a string, or a function.\n   * @default ({ formattedValue }) => formattedValue\n   */\n  minLabel: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  /**\n   * The position of the legend.\n   */\n  position: PropTypes.shape({\n    horizontal: PropTypes.oneOf(['left', 'middle', 'right']).isRequired,\n    vertical: PropTypes.oneOf(['bottom', 'middle', 'top']).isRequired\n  }),\n  /**\n   * The scale used to display gradient colors.\n   * @default 'linear'\n   */\n  scaleType: PropTypes.oneOf(['linear', 'log', 'pow', 'sqrt', 'time', 'utc']),\n  /**\n   * The space between the gradient bar and the labels.\n   * @default 4\n   */\n  spacing: PropTypes.number,\n  /**\n   * The thickness of the gradient bar.\n   * @default 5\n   */\n  thickness: PropTypes.number\n} : void 0;\nexport { ContinuousColorLegend };","map":{"version":3,"names":["_extends","React","PropTypes","useTheme","ChartsContinuousGradient","useChartId","useDrawingArea","getScale","getPercentageValue","ChartsText","getStringSize","useAxis","jsx","_jsx","jsxs","_jsxs","getPositionOffset","position","legendBox","svgBox","offsetX","offsetY","horizontal","width","vertical","height","getElementPositions","text1Box","barBox","text2Box","params","direction","text1","y","dominantBaseline","text2","spacing","bar","totalWidth","Math","max","totalHeight","boundingBox","align","textAnchor","x","defaultLabelFormatter","_ref","formattedValue","ContinuousColorLegend","props","_colorMap$min","_colorMap$max","_axisItem$valueFormat","_axisItem$valueFormat2","_axisItem$valueFormat3","_axisItem$valueFormat4","theme","id","idProp","minLabel","maxLabel","scaleType","length","thickness","labelStyle","typography","subtitle1","axisDirection","axisId","chartId","concat","isRTL","axisItem","left","right","top","bottom","refLength","size","isReversed","colorMap","type","colorScale","minValue","min","maxValue","scale","formattedMin","valueFormatter","call","location","toLocaleString","formattedMax","minText","value","maxText","legendPositions","svgBoundingBox","positionOffset","Fragment","children","gradientId","gradientUnits","text","style","fill","process","env","NODE_ENV","propTypes","oneOf","oneOfType","number","string","object","func","shape","isRequired"],"sources":["/Users/neilk/Documents/WebDev/workout-tracker/node_modules/@mui/x-charts/esm/ChartsLegend/ContinuousColorLegend.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { useTheme } from '@mui/material/styles';\nimport ChartsContinuousGradient from '../internals/components/ChartsAxesGradients/ChartsContinuousGradient';\nimport { useChartId, useDrawingArea } from '../hooks';\nimport { getScale } from '../internals/getScale';\nimport { getPercentageValue } from '../internals/getPercentageValue';\nimport { ChartsText } from '../ChartsText';\nimport { getStringSize } from '../internals/domUtils';\nimport { useAxis } from './useAxis';\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nfunction getPositionOffset(position, legendBox, svgBox) {\n  let offsetX = 0;\n  let offsetY = 0;\n  switch (position.horizontal) {\n    case 'left':\n      offsetX = 0;\n      break;\n    case 'middle':\n      offsetX = (svgBox.width - legendBox.width) / 2;\n      break;\n    case 'right':\n    default:\n      offsetX = svgBox.width - legendBox.width;\n      break;\n  }\n  switch (position.vertical) {\n    case 'top':\n      offsetY = 0;\n      break;\n    case 'middle':\n      offsetY = (svgBox.height - legendBox.height) / 2;\n      break;\n    case 'bottom':\n    default:\n      offsetY = svgBox.height - legendBox.height;\n      break;\n  }\n  return {\n    offsetX,\n    offsetY\n  };\n}\n\n/**\n * Takes placement parameters and element bounding boxes.\n * Returns the x, y coordinates of the elements. And the textAnchor, dominantBaseline for texts.\n */\nfunction getElementPositions(text1Box, barBox, text2Box, params) {\n  if (params.direction === 'column') {\n    const text1 = {\n      y: text1Box.height,\n      dominantBaseline: 'auto'\n    };\n    const text2 = {\n      y: text1Box.height + 2 * params.spacing + barBox.height,\n      dominantBaseline: 'hanging'\n    };\n    const bar = {\n      y: text1Box.height + params.spacing\n    };\n    const totalWidth = Math.max(text1Box.width, barBox.width, text2Box.width);\n    const totalHeight = text1Box.height + barBox.height + text2Box.height + 2 * params.spacing;\n    const boundingBox = {\n      width: totalWidth,\n      height: totalHeight\n    };\n    switch (params.align) {\n      case 'start':\n        return {\n          text1: _extends({}, text1, {\n            textAnchor: 'start',\n            x: 0\n          }),\n          text2: _extends({}, text2, {\n            textAnchor: 'start',\n            x: 0\n          }),\n          bar: _extends({}, bar, {\n            x: 0\n          }),\n          boundingBox\n        };\n      case 'end':\n        return {\n          text1: _extends({}, text1, {\n            textAnchor: 'end',\n            x: totalWidth\n          }),\n          text2: _extends({}, text2, {\n            textAnchor: 'end',\n            x: totalWidth\n          }),\n          bar: _extends({}, bar, {\n            x: totalWidth - barBox.width\n          }),\n          boundingBox\n        };\n      case 'middle':\n      default:\n        return {\n          text1: _extends({}, text1, {\n            textAnchor: 'middle',\n            x: totalWidth / 2\n          }),\n          text2: _extends({}, text2, {\n            textAnchor: 'middle',\n            x: totalWidth / 2\n          }),\n          bar: _extends({}, bar, {\n            x: totalWidth / 2 - barBox.width / 2\n          }),\n          boundingBox\n        };\n    }\n  } else {\n    const text1 = {\n      x: text1Box.width,\n      textAnchor: 'end'\n    };\n    const text2 = {\n      x: text1Box.width + 2 * params.spacing + barBox.width,\n      textAnchor: 'start'\n    };\n    const bar = {\n      x: text1Box.width + params.spacing\n    };\n    const totalHeight = Math.max(text1Box.height, barBox.height, text2Box.height);\n    const totalWidth = text1Box.width + barBox.width + text2Box.width + 2 * params.spacing;\n    const boundingBox = {\n      width: totalWidth,\n      height: totalHeight\n    };\n    switch (params.align) {\n      case 'start':\n        return {\n          text1: _extends({}, text1, {\n            dominantBaseline: 'hanging',\n            y: 0\n          }),\n          text2: _extends({}, text2, {\n            dominantBaseline: 'hanging',\n            y: 0\n          }),\n          bar: _extends({}, bar, {\n            y: 0\n          }),\n          boundingBox\n        };\n      case 'end':\n        return {\n          text1: _extends({}, text1, {\n            dominantBaseline: 'auto',\n            y: totalHeight\n          }),\n          text2: _extends({}, text2, {\n            dominantBaseline: 'auto',\n            y: totalHeight\n          }),\n          bar: _extends({}, bar, {\n            y: totalHeight - barBox.height\n          }),\n          boundingBox\n        };\n      case 'middle':\n      default:\n        return {\n          text1: _extends({}, text1, {\n            dominantBaseline: 'central',\n            y: totalHeight / 2\n          }),\n          text2: _extends({}, text2, {\n            dominantBaseline: 'central',\n            y: totalHeight / 2\n          }),\n          bar: _extends({}, bar, {\n            y: totalHeight / 2 - barBox.height / 2\n          }),\n          boundingBox\n        };\n    }\n  }\n}\nconst defaultLabelFormatter = ({\n  formattedValue\n}) => formattedValue;\nfunction ContinuousColorLegend(props) {\n  const theme = useTheme();\n  const {\n    id: idProp,\n    minLabel = defaultLabelFormatter,\n    maxLabel = defaultLabelFormatter,\n    scaleType = 'linear',\n    direction,\n    length = '50%',\n    thickness = 5,\n    spacing = 4,\n    align = 'middle',\n    labelStyle = theme.typography.subtitle1,\n    position,\n    axisDirection,\n    axisId\n  } = props;\n  const chartId = useChartId();\n  const id = idProp ?? `gradient-legend-${chartId}`;\n  const isRTL = theme.direction === 'rtl';\n  const axisItem = useAxis({\n    axisDirection,\n    axisId\n  });\n  const {\n    width,\n    height,\n    left,\n    right,\n    top,\n    bottom\n  } = useDrawingArea();\n  const refLength = direction === 'column' ? height + top + bottom : width + left + right;\n  const size = getPercentageValue(length, refLength);\n  const isReversed = direction === 'column';\n  const colorMap = axisItem?.colorMap;\n  if (!colorMap || !colorMap.type || colorMap.type !== 'continuous') {\n    return null;\n  }\n\n  // Define the coordinate to color mapping\n\n  const colorScale = axisItem.colorScale;\n  const minValue = colorMap.min ?? 0;\n  const maxValue = colorMap.max ?? 100;\n  const scale = getScale(scaleType, [minValue, maxValue], isReversed ? [size, 0] : [0, size]);\n\n  // Get texts to display\n\n  const formattedMin = axisItem.valueFormatter?.(minValue, {\n    location: 'legend'\n  }) ?? minValue.toLocaleString();\n  const formattedMax = axisItem.valueFormatter?.(maxValue, {\n    location: 'legend'\n  }) ?? maxValue.toLocaleString();\n  const minText = typeof minLabel === 'string' ? minLabel : minLabel({\n    value: minValue ?? 0,\n    formattedValue: formattedMin\n  });\n  const maxText = typeof maxLabel === 'string' ? maxLabel : maxLabel({\n    value: maxValue ?? 0,\n    formattedValue: formattedMax\n  });\n  const text1 = isReversed ? maxText : minText;\n  const text2 = isReversed ? minText : maxText;\n  const text1Box = getStringSize(text1, _extends({}, labelStyle));\n  const text2Box = getStringSize(text2, _extends({}, labelStyle));\n\n  // Place bar and texts\n\n  const barBox = direction === 'column' || isRTL && direction === 'row' ? {\n    width: thickness,\n    height: size\n  } : {\n    width: size,\n    height: thickness\n  };\n  const legendPositions = getElementPositions(text1Box, barBox, text2Box, {\n    spacing,\n    align,\n    direction\n  });\n  const svgBoundingBox = {\n    width: width + left + right,\n    height: height + top + bottom\n  };\n  const positionOffset = getPositionOffset(_extends({\n    horizontal: 'middle',\n    vertical: 'top'\n  }, position), legendPositions.boundingBox, svgBoundingBox);\n  return /*#__PURE__*/_jsxs(React.Fragment, {\n    children: [/*#__PURE__*/_jsx(ChartsContinuousGradient, {\n      isReversed: isReversed,\n      gradientId: id,\n      size: size,\n      direction: direction === 'row' ? 'x' : 'y',\n      scale: scale,\n      colorScale: colorScale,\n      colorMap: colorMap,\n      gradientUnits: \"objectBoundingBox\"\n    }), /*#__PURE__*/_jsx(ChartsText, {\n      text: text1,\n      x: positionOffset.offsetX + legendPositions.text1.x,\n      y: positionOffset.offsetY + legendPositions.text1.y,\n      style: _extends({\n        dominantBaseline: legendPositions.text1.dominantBaseline,\n        textAnchor: legendPositions.text1.textAnchor\n      }, labelStyle)\n    }), /*#__PURE__*/_jsx(\"rect\", _extends({\n      x: positionOffset.offsetX + legendPositions.bar.x,\n      y: positionOffset.offsetY + legendPositions.bar.y\n    }, barBox, {\n      fill: `url(#${id})`\n    })), /*#__PURE__*/_jsx(ChartsText, {\n      text: text2,\n      x: positionOffset.offsetX + legendPositions.text2.x,\n      y: positionOffset.offsetY + legendPositions.text2.y,\n      style: _extends({\n        dominantBaseline: legendPositions.text2.dominantBaseline,\n        textAnchor: legendPositions.text2.textAnchor\n      }, labelStyle)\n    })]\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? ContinuousColorLegend.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * The alignment of the texts with the gradient bar.\n   * @default 'middle'\n   */\n  align: PropTypes.oneOf(['end', 'middle', 'start']),\n  /**\n   * The axis direction containing the color configuration to represent.\n   * @default 'z'\n   */\n  axisDirection: PropTypes.oneOf(['x', 'y', 'z']),\n  /**\n   * The id of the axis item with the color configuration to represent.\n   * @default The first axis item.\n   */\n  axisId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  /**\n   * The direction of the legend layout.\n   * The default depends on the chart.\n   */\n  direction: PropTypes.oneOf(['column', 'row']),\n  /**\n   * A unique identifier for the gradient.\n   * @default auto-generated id\n   */\n  id: PropTypes.string,\n  /**\n   * The style applied to labels.\n   * @default theme.typography.subtitle1\n   */\n  labelStyle: PropTypes.object,\n  /**\n   * The length of the gradient bar.\n   * Can be a number (in px) or a string with a percentage such as '50%'.\n   * The '100%' is the length of the svg.\n   * @default '50%'\n   */\n  length: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  /**\n   * The label to display at the maximum side of the gradient.\n   * Can either be a string, or a function.\n   * If not defined, the formatted maximal value is display.\n   * @default ({ formattedValue }) => formattedValue\n   */\n  maxLabel: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  /**\n   * The label to display at the minimum side of the gradient.\n   * Can either be a string, or a function.\n   * @default ({ formattedValue }) => formattedValue\n   */\n  minLabel: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  /**\n   * The position of the legend.\n   */\n  position: PropTypes.shape({\n    horizontal: PropTypes.oneOf(['left', 'middle', 'right']).isRequired,\n    vertical: PropTypes.oneOf(['bottom', 'middle', 'top']).isRequired\n  }),\n  /**\n   * The scale used to display gradient colors.\n   * @default 'linear'\n   */\n  scaleType: PropTypes.oneOf(['linear', 'log', 'pow', 'sqrt', 'time', 'utc']),\n  /**\n   * The space between the gradient bar and the labels.\n   * @default 4\n   */\n  spacing: PropTypes.number,\n  /**\n   * The thickness of the gradient bar.\n   * @default 5\n   */\n  thickness: PropTypes.number\n} : void 0;\nexport { ContinuousColorLegend };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}